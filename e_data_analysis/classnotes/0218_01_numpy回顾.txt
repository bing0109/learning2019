
构造全为0的2行3列4面的三维数组
>>> np.zeros((2,3,4))
array([[[0., 0., 0., 0.],
        [0., 0., 0., 0.],
        [0., 0., 0., 0.]],

       [[0., 0., 0., 0.],
        [0., 0., 0., 0.],
        [0., 0., 0., 0.]]])
构造全为1的数组
>>> np.ones((2,3))
array([[1., 1., 1.],
       [1., 1., 1.]])
构造全为10的2行3列数组
>>> np.full((2,3),10)
array([[10, 10, 10],
       [10, 10, 10]])
构造全为4的2行3列数组
>>> np.full((2,3),4)
array([[4, 4, 4],
       [4, 4, 4]])
构造单位矩阵
>>> np.eye((3))
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
>>> np.eye(3)
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
>>> 

以标准正太分布取随机数生成3行3列数组
>>> np.random.randn(3,3)
array([[-0.57517222, -1.56224676, -1.03200979],
       [-0.71437424,  1.75706551, -0.26211674],
       [-0.74208832,  0.27787167, -0.83581936]])
以平均值=10,标准差=1的正太分布取随机数生成4行3列数组
>>> np.random.normal(10,1,(4,4))
array([[10.10996944, 10.34130815, 10.52985476,  9.90196135],
       [ 9.33948258,  9.65028733, 11.08465918, 10.36059592],
       [ 8.97259382,  8.96111902, 11.73697105,  9.14215892],
       [ 9.78599012,  8.99259202,  9.10990388,  8.63941923]])
>>> 
产生0-1的均匀分布，2行3列数组
>>> np.random.rand(2,3)
array([[0.65645851, 0.43889748, 0.62064582],
       [0.51161547, 0.103323  , 0.86864037]])
统计均价分布数组中小于0.3的元素的数量
>>> (np.random.rand(20,20)<0.3).sum()
119

给定上下限范围(20-40)，生成3行，3列的整数数组
>>> np.random.randint(20,40,(3,3))
array([[23, 23, 37],
       [26, 31, 38],
       [35, 37, 26]])
       
       
二项分布
numpy.random.RandomState.binomial(n, p, size=None)
表示对一个二项分布进行采样（size表示采样的次数，draw samples from a binomial distribution.），参数中的n, p分别对应于公式中的n,p，函数的返回值表示n中成功（success）的次数（也即N）。可能说起来比较抽象，我们以一个具体的实例进行阐释：说野外正在进行9（n=9）口石油勘探井的发掘工作，每一口井能够开发出油的概率是0.1（p=0.1）。请问，最终所有的勘探井都勘探失败的概率？

>>> np.random.binomial(9,0.1,10)
array([2, 1, 0, 2, 1, 0, 4, 2, 1, 0])
如上，在10次取样过程中，第一次有2口井勘探成功，第二次有1口井勘探成功，第三次有0口井勘探成功，第四次有2口井勘探成功.。。。
取样10000次并算概率，全部勘探失败的概率
>>> sum(np.random.binomial(9,0.1,10000)==0)/10000
0.3909
>>> sum(np.random.binomial(9,0.1,100000)==0)/100000
0.38871

取样100000次，4口井勘探成功的概率
>>> sum(np.random.binomial(9,0.1,100000)==4)/100000
0.00755
>>> sum(np.random.binomial(9,0.1,100000)==3)/100000
0.04395
>>> sum(np.random.binomial(9,0.1,100000)==0)/100000
0.38679
>>> sum(np.random.binomial(9,0.1,100000)==1)/100000
0.38595
>>> sum(np.random.binomial(9,0.1,100000)==2)/100000
0.17159
>>> sum(np.random.binomial(9,0.1,100000)==3)/100000
0.04414
>>> sum(np.random.binomial(9,0.1,100000)==4)/100000
0.00764
>>> sum(np.random.binomial(9,0.1,100000)==5)/100000
0.00086
>>> sum(np.random.binomial(9,0.1,100000)==6)/100000
5e-05
应该是概率太小，精度不够显示为0
>>> sum(np.random.binomial(9,0.1,100000)==8)/100000
0.0


生成2-6范围内，3行3列数组
>>> a = np.random.randint(2,6,(3,3))
>>> a
array([[4, 3, 4],
       [3, 2, 4],
       [5, 3, 3]])
       
shuffle()把数组随机打乱
>>> np.random.shuffle(a)
>>> a
array([[4, 3, 4],
       [5, 3, 3],
       [3, 2, 4]])
>>> np.random.shuffle(a)
>>> a
array([[4, 3, 4],
       [3, 2, 4],
       [5, 3, 3]])
>>> np.random.shuffle(a)
>>> a
array([[5, 3, 3],
       [3, 2, 4],
       [4, 3, 4]])
>>> 

随机种子seed()
np.random.seed(0)
    0-2范围内，同一个seed取值，多次随机取值结果都一样
    None，seed不生效，和不写一样
例子：
a和b数组元素一样
>>> np.random.seed(0)
>>> a = np.random.randint(1,5,(3,3))
>>> a
array([[1, 4, 2],
       [1, 4, 4],
       [4, 4, 2]])
>>> np.random.seed(0)
>>> b = np.random.randint(1,5,(3,3))
>>> b
array([[1, 4, 2],
       [1, 4, 4],
       [4, 4, 2]])

c和d一样
>>> np.random.seed(1)
>>> c = np.random.randint(1,5,(3,3))
>>> c
array([[2, 4, 1],
       [1, 4, 2],
       [4, 2, 4]])
>>> np.random.seed(1)
>>> d = np.random.randint(1,5,(3,3))
>>> d
array([[2, 4, 1],
       [1, 4, 2],
       [4, 2, 4]])
>>> 

>>> np.random.seed(None)
>>> e = np.random.randint(1,5,(3,3))
>>> e
array([[1, 2, 2],
       [3, 1, 1],
       [1, 1, 2]])


转换数据类型
>>> a = np.random.randn(2,3)
>>> a
array([[-0.60863751, -0.28757088, -0.21721937],
       [ 0.50899448, -0.27719044,  0.79880674]])
>>> a.dtype
dtype('float64')
>>> np.array(a,dtype='int32')
array([[0, 0, 0],
       [0, 0, 0]], dtype=int32)
>>> np.array(a,dtype='int32').dtype
dtype('int32')

astype转换数据类型
>>> a = np.ones((2,3))
>>> a
array([[1., 1., 1.],
       [1., 1., 1.]])
>>> a.dtype
dtype('float64')
>>> a.astype(np.int32)
array([[1, 1, 1],
       [1, 1, 1]], dtype=int32)
>>> a
array([[1., 1., 1.],
       [1., 1., 1.]])



重构数组，reshape
>>> a = np.random.randint(1,9,(4,3))
>>> a
array([[3, 5, 6],
       [2, 4, 2],
       [3, 7, 1],
       [3, 5, 2]])
>>> a.reshape(3,4)
array([[3, 5, 6, 2],
       [4, 2, 3, 7],
       [1, 3, 5, 2]])
>>> a.reshape(2,2,3)
array([[[3, 5, 6],
        [2, 4, 2]],

       [[3, 7, 1],
        [3, 5, 2]]])


从[0,1)范围内以步长0.1取值，生成一维数组
>>> a = np.arange(0,1,0.1)
>>> a
array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
>>> len(a)
10
>>> a.size
10
随机打乱数组
>>> np.random.shuffle(a)
>>> a
array([0.8, 0. , 0.6, 0.9, 0.1, 0.4, 0.7, 0.5, 0.3, 0.2])
重构数组
>>> a.reshape(2,5)
array([[0.8, 0. , 0.6, 0.9, 0.1],
       [0.4, 0.7, 0.5, 0.3, 0.2]])



深复制，浅复制


切片索引


花式索引
>>> a=np.arange(1,21).reshape(4,5)
>>> a
array([[ 1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10],
       [11, 12, 13, 14, 15],
       [16, 17, 18, 19, 20]])
>>> a[[0,0,2],[0,2,2]]  # 取a的[0,0][0,2][2,2]位置的元素
array([ 1,  3, 13])
>>> a[:,[2,0]]  # 取a的第2列，第0列的数据
array([[ 3,  1],
       [ 8,  6],
       [13, 11],
       [18, 16]])

布尔型索引
>>> a[a>6]
array([ 7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])
>>> 



以上三种索引方式可以互相嵌套





运算

加
>>> a = np.arange(1,7,1).reshape(2,3)
>>> a
array([[1, 2, 3],
       [4, 5, 6]])
    加1维数组
    >>> a+np.array([1,2,3])
    array([[2, 4, 6],
           [5, 7, 9]])

    >>> a+np.array([1,2])
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    ValueError: operands could not be broadcast together with shapes (2,3) (2,) 
    加数字
    >>> a+2
    array([[3, 4, 5],
           [6, 7, 8]])
    加数组，第一行所有元素加1，第二行所有元素加2
    >>> a+np.array([[1],[2]])
    array([[2, 3, 4],
           [6, 7, 8]])
    >>> 


一元运算


二元运算
    mod求模（除以某个数后取余数）
        >>> a = np.random.randint(1,10,(3,4))
        >>> a
        array([[1, 5, 3, 8],
               [8, 9, 7, 4],
               [8, 8, 5, 6]])
        >>> np.mod(a,3)
        array([[1, 2, 0, 2],
               [2, 0, 1, 1],
               [2, 2, 2, 0]])



求矩阵的特征值和特征向量
    >>> a
    array([[8, 2, 2],
           [4, 1, 9],
           [7, 5, 6]])
    >>> np.linalg.matrix_rank(a)    # 求矩阵a的秩
    3
    >>> np.linalg.eig(a)    # 求矩阵a的特征值和特征向量
    (array([14.3368037 ,  4.15495696, -3.49176065]), array([[-0.40647681, -0.58889689,  0.08561944],
           [-0.59170704,  0.64450371, -0.90615278],
           [-0.69617482,  0.48766322,  0.41419374]]))
    >>> np.linalg.eig(a)[0]     # 取矩阵a的特征值
    array([14.3368037 ,  4.15495696, -3.49176065])
    >>> np.linalg.eig(a)[1]     # 取矩阵a的特征向量
    array([[-0.40647681, -0.58889689,  0.08561944],
           [-0.59170704,  0.64450371, -0.90615278],
           [-0.69617482,  0.48766322,  0.41419374]])
    >>> c,d = np.linalg.eig(a)  # 分别取矩阵a的特征值和特征向量
    >>> c
    array([14.3368037 ,  4.15495696, -3.49176065])
    >>> d
    array([[-0.40647681, -0.58889689,  0.08561944],
           [-0.59170704,  0.64450371, -0.90615278],
           [-0.69617482,  0.48766322,  0.41419374]])
    >>> 







































